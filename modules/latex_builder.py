import subprocess
from pathlib import Path
import shutil
import tempfile
import os
from typing import Optional
import logging

logger = logging.getLogger(__name__)

class LatexBuilder:
    """Handles LaTeX document creation and compilation"""
    
    def __init__(self, output_dir: Optional[Path] = None):
        self.output_dir = output_dir or Path('outputs')
        self.output_dir.mkdir(exist_ok=True)
        
        # LaTeX document template - use $TITLE$ and $CONTENT$ placeholders to avoid conflicts with LaTeX braces
        self.latex_template = r"""\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}

% Custom colors
\definecolor{notecolor}{RGB}{41, 128, 185}
\definecolor{questioncolor}{RGB}{39, 174, 96}

% Custom commands
\newcommand{\keyword}[1]{\textbf{\textcolor{notecolor}{#1}}}
\newcommand{\important}[1]{\textit{\textcolor{red}{#1}}}

% List settings
\setlist[enumerate]{itemsep=4pt, topsep=8pt}
\setlist[itemize]{itemsep=2pt, topsep=6pt}

\title{$TITLE$}
\author{Generated by AI Study Assistant}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

$CONTENT$

% Footer
\vfill
\begin{center}
\small Generated on \today\ from source material.
\end{center}

\end{document}"""
    
    def create_latex_file(self, content: str, filename: str, title: str = "Study Notes") -> Path:
        """
        Create a complete LaTeX file from content
        Returns: Path to created .tex file
        """
        logger.info(f"Creating LaTeX file: {filename}")
        
        # Ensure filename has .tex extension
        if not filename.endswith('.tex'):
            filename += '.tex'
        
        tex_path = self.output_dir / filename
        
        # Replace placeholders in template using string replace instead of .format()
        latex_doc = self.latex_template.replace('$TITLE$', title)
        latex_doc = latex_doc.replace('$CONTENT$', content)
        
        logger.debug(f"Template variables replaced. Document length: {len(latex_doc)} characters")
        
        # Write to file
        with open(tex_path, 'w', encoding='utf-8') as f:
            f.write(latex_doc)
        
        logger.info(f"LaTeX file created successfully: {tex_path}")
        return tex_path
    
    def compile_to_pdf(self, tex_path: Path) -> Path:
        """
        Compile LaTeX file to PDF
        Returns: Path to generated PDF
        """
        logger.info(f"Starting PDF compilation from: {tex_path}")
        
        if not tex_path.exists():
            logger.error(f"LaTeX file not found: {tex_path}")
            raise FileNotFoundError(f"LaTeX file not found: {tex_path}")
        
        # Try pdflatex first
        if self.check_latex_available():
            logger.info("LaTeX compiler available. Starting compilation...")
            return self._compile_with_pdflatex(tex_path)
        else:
            logger.warning("pdflatex not available. Trying ReportLab fallback...")
            return self._compile_with_reportlab(tex_path)
    
    def _compile_with_pdflatex(self, tex_path: Path) -> Path:
        """Compile LaTeX to PDF using pdflatex"""
        logger.info(f"Compiling with pdflatex: {tex_path}")
        
        # Create temporary directory for compilation
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_tex = Path(temp_dir) / tex_path.name
            
            # Copy .tex file to temp directory
            logger.debug(f"Copying {tex_path} to {temp_tex}")
            shutil.copy(tex_path, temp_tex)
            
            # Run pdflatex (multiple runs for references)
            for i in range(2):  # Run twice for proper references
                logger.debug(f"Running pdflatex (run {i+1}/2)...")
                result = subprocess.run(
                    [
                        'pdflatex',
                        '-interaction=nonstopmode',
                        '-output-directory', temp_dir,
                        str(temp_tex)
                    ],
                    capture_output=True,
                    text=True
                )
                
                if result.returncode != 0:
                    logger.error(f"LaTeX compilation error (run {i+1}):")
                    logger.error(f"STDOUT: {result.stdout}")
                    logger.error(f"STDERR: {result.stderr}")
                    if i == 0:  # Only raise on first run failure
                        raise RuntimeError(f"LaTeX compilation failed:\n{result.stderr}")
                else:
                    logger.debug(f"LaTeX run {i+1} completed successfully")
            
            # Define PDF path
            pdf_name = tex_path.stem + '.pdf'
            pdf_path = self.output_dir / pdf_name
            
            # Move PDF to output directory
            temp_pdf = Path(temp_dir) / pdf_name
            if temp_pdf.exists():
                logger.debug(f"Moving {temp_pdf} to {pdf_path}")
                shutil.move(temp_pdf, pdf_path)
                
                # Clean up auxiliary files
                for aux_file in Path(temp_dir).glob(f"{tex_path.stem}.*"):
                    if aux_file.suffix not in ['.pdf', '.tex']:
                        logger.debug(f"Cleaning up: {aux_file}")
                        aux_file.unlink(missing_ok=True)
                
                logger.info(f"PDF compiled successfully: {pdf_path}")
                return pdf_path
            else:
                logger.error("PDF was not generated despite successful compilation")
                raise RuntimeError("PDF was not generated")
    
    def _compile_with_reportlab(self, tex_path: Path) -> Path:
        """Fallback: Convert LaTeX to PDF using ReportLab with better LaTeX parsing"""
        logger.info("Using ReportLab to generate PDF from LaTeX content")
        
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Table, TableStyle
            from reportlab.lib import colors
            from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY, TA_LEFT
            import re
        except ImportError:
            logger.error("ReportLab not installed. Cannot generate PDF.")
            raise RuntimeError("ReportLab not available for PDF generation. Install with: pip install reportlab")
        
        try:
            # Read LaTeX file content
            with open(tex_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            logger.debug(f"LaTeX file read. Size: {len(content)} characters")
            
            # Extract title
            title = "Study Notes"
            title_match = re.search(r'\\title\{([^}]+)\}', content)
            if title_match:
                title = title_match.group(1).strip()
            
            # Extract document body
            body_match = re.search(r'\\begin\{document\}(.*?)\\end\{document\}', content, re.DOTALL)
            if body_match:
                body = body_match.group(1)
            else:
                body = content
            
            logger.debug(f"Document body extracted. Size: {len(body)} characters")
            
            # Remove table of contents and maketitle commands
            body = re.sub(r'\\maketitle\s*', '', body)
            body = re.sub(r'\\tableofcontents\s*', '', body)
            body = re.sub(r'\\newpage\s*', '\n[PAGEBREAK]\n', body)
            
            # Create PDF document
            pdf_name = tex_path.stem + '.pdf'
            pdf_path = self.output_dir / pdf_name
            
            logger.debug(f"Creating PDF: {pdf_path}")
            doc = SimpleDocTemplate(str(pdf_path), pagesize=letter, topMargin=0.75*inch, bottomMargin=0.75*inch)
            story = []
            styles = getSampleStyleSheet()
            
            # Add title
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                textColor=colors.HexColor('#2980b9'),
                spaceAfter=20,
                alignment=TA_CENTER,
                fontName='Helvetica-Bold'
            )
            story.append(Paragraph(title, title_style))
            story.append(Spacer(1, 0.3*inch))
            
            # Process body content
            section_style = ParagraphStyle(
                'SectionHead',
                parent=styles['Heading2'],
                fontSize=14,
                textColor=colors.HexColor('#16a085'),
                spaceAfter=10,
                spaceBefore=12,
                fontName='Helvetica-Bold'
            )
            
            subsection_style = ParagraphStyle(
                'SubsectionHead',
                parent=styles['Heading3'],
                fontSize=12,
                textColor=colors.HexColor('#2980b9'),
                spaceAfter=8,
                spaceBefore=10,
                fontName='Helvetica-Bold'
            )
            
            body_style = ParagraphStyle(
                'BodyText',
                parent=styles['Normal'],
                fontSize=10,
                alignment=TA_JUSTIFY,
                spaceAfter=10,
                leading=14
            )
            
            # Process content line by line
            lines = body.split('\n')
            for line in lines:
                line = line.strip()
                
                if not line:
                    story.append(Spacer(1, 6))
                    continue
                
                if line == '[PAGEBREAK]':
                    story.append(PageBreak())
                    continue
                
                # Check for sections
                section_match = re.match(r'\\section(?:\*)?\{([^}]+)\}', line)
                if section_match:
                    section_title = section_match.group(1)
                    story.append(Paragraph(section_title, section_style))
                    continue
                
                # Check for subsections
                subsection_match = re.match(r'\\subsection(?:\*)?\{([^}]+)\}', line)
                if subsection_match:
                    subsection_title = subsection_match.group(1)
                    story.append(Paragraph(subsection_title, subsection_style))
                    continue
                
                # Remove LaTeX formatting but preserve text
                # Handle \textbf{text} -> <b>text</b>
                processed = re.sub(r'\\textbf\{([^}]+)\}', r'<b>\1</b>', line)
                # Handle \textit{text} -> <i>text</i>
                processed = re.sub(r'\\textit\{([^}]+)\}', r'<i>\1</i>', processed)
                # Handle \textcolor{color}{text} -> text
                processed = re.sub(r'\\textcolor\{[^}]+\}\{([^}]+)\}', r'\1', processed)
                # Handle \cellcolor and other commands
                processed = re.sub(r'\\cellcolor\{[^}]+\}', '', processed)
                # Handle bullet points
                processed = processed.replace('\\item ', 'â€¢ ')
                # Remove remaining braces from unclosed commands
                processed = processed.replace('{', '').replace('}', '')
                # Remove other LaTeX commands
                processed = re.sub(r'\\[a-zA-Z]+\*?\{?', '', processed)
                processed = re.sub(r'\\[a-zA-Z]+\*?', '', processed)
                
                if processed.strip():
                    try:
                        story.append(Paragraph(processed, body_style))
                    except Exception as e:
                        logger.warning(f"Could not add paragraph: {str(e)[:100]}")
                        # Try with escaped content
                        try:
                            escaped = processed.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                            story.append(Paragraph(escaped, body_style))
                        except:
                            pass
            
            # Build PDF
            logger.debug("Building PDF document...")
            doc.build(story)
            
            logger.info(f"PDF generated successfully with ReportLab: {pdf_path}")
            return pdf_path
            
        except Exception as e:
            logger.error(f"ReportLab PDF generation failed: {str(e)}", exc_info=True)
            raise RuntimeError(f"PDF generation failed: {str(e)}")
    
    def check_latex_available(self) -> bool:
        """Check if LaTeX compiler is available"""
        try:
            result = subprocess.run(
                ['pdflatex', '--version'],
                capture_output=True,
                text=True
            )
            return result.returncode == 0
        except (subprocess.SubprocessError, FileNotFoundError):
            return False
    
    def get_available_compilers(self) -> list:
        """Get list of available LaTeX compilers"""
        compilers = ['pdflatex', 'xelatex', 'lualatex']
        available = []
        
        for compiler in compilers:
            try:
                subprocess.run([compiler, '--version'], 
                             capture_output=True, 
                             check=False)
                available.append(compiler)
            except (subprocess.SubprocessError, FileNotFoundError):
                pass
        
        return available